# 자바 ORM 표준 JPA 프로그래밍 - CH01
---
**객체모델링**에서  
  
"왜 실무에서 테이블 설계는 다들 열심히 하면서 제대로 된 객채 모델링은 하지않을까?"  
"객체지향의 장점을 포기하고 단순히 <b style="color:red;">테이블에 맞추어 데이터 전달역할</b>만 하도록 개발?" 
   
→ 결국, 객체모델링을 SQL로 풀어내는데 많은 코드와 노력이 필요했으며, <b style="color:red;">객체모델은 점점 데이터 중심의 모델</b>로 변해감
  
  
** ORM(Object Relational Mapping) : 객체와 관계형 데이터베이스간의 차이를 중간에서 해결해주는 프레임워크  
** JPA(Java Persistance API) : 자바진영의 ORM 기술표준

- JPA는 반복적이 CRUD SQL을 알아서 처리
- 실행시점애 자동으로 SQL을 만들어서 실행, 개발자는 SQL을 직접작성하는 것이 아니라 어떤 SQL이 실행될지만 생각
- 조회된 결과를 객체로 맵핑하는 작업도 대부분 자동으로 처리
- 애플리케이션을 SQL중심이 아닌 객체중심으로 개발 → 생산성과 유지보수가 좋아짐, 테스트를 작성하기에도 편리해짐

## 1.1 SQL을 직접다룰때 발생하는 문제점
- 관계형데이터베이스는 가장 대중적, 신뢰할만한 안정한 데이터 저장소

    ### 1.1.1 반복적
    ex) 회원테이블이 있고, 회원을 CRUD하는 기능을 개발할 때  
        a. 회원조회기능 구현  
            - 쿼리문 작성 → JDBC API를 사용해서 SQL문 실행 → 결과를 MemberDTO객체로 Mapping  
        b. 회원등록기능 구현  
        c. 회원수정기능 구현  
        d. 회원삭제기능 구현  

    <b style="color:red;">→ 결론적으로 반복적으로 쿼리문 작성, JDBC API 사용하는 연속</b>


    ### 1.1.2 SQL의존적 개발
    - 만약, 회원의 연락처를 MemberDTO클래스 필드에 추가해야한다면
    - 필드 하나를 추가할때에도 DAO의 모든 CRUD코드와 쿼리문을 수정해야함


    ### 1.1.3 JPA와 문제해결
    - JPA를 사용하면 객체를 DB에 저장하고 관리할때, 개발자가 직업 SQL문을 작성하는 것이 아니라 JPA가 제공하는 API를 사용 : JPA가 적절한 SQL문을 작성해서 DB에 전달

    - JPA가 제공하는 CRUD API
        - 저장기능 : persist() 메서드 → INSERT SQL
        - 조회기능 : find() 메서드 → SELECT SQL
        - 수정기능 : 별도 수정메서드 제공 X, 객체를 조회해서 값을 변경하면 → UPDATE SQL
        - 연관된객체조회 : 연관된 객체를 사용하는 시점에 적절한 SELECT SQL실행


## 1.2 패러다임의 불일치
- 애플리케이션은 발전하면서 그 내부의 복잡성도 점점커짐
- 복잡성을 제어하지 못하면 유지보수가 어려운 애플리케이션 : <b style="color:skyblue;">추상화, 정보은닉, 상속, 다형성(복잡성을 제어할수있는 객체지향 언어의 장치, 특성)</b>
- 관계형 데이터베이스는 데이터 중심으로 구조화, 집합적인 사고요구, 객체지향언어의 특성이 없음
- 객체와 관계형 데이터베이스는 지향하는 목적이 서로다름 : 기능과 표현방법이 다름<b style="color:red;">(패러다임 불일치 문제)</b>
- 객체구조를 데이터베이스에 저장하는데 한계가 존재, 이 문제를 극복하기 위해 많은 시간과 코드를 소비
- 결국 객체 모델링은 힘을 잃고 점점 데이터 중심의 모델로 변해감


## 1.3 JPA란?
- JPA(Java Persitance API) : 자바진영의 ORM 표준기술, API 표준명세
- 애플리케이션과 JDBC사이에서 동작  
![ex_screenshot](/img/jpa.jpg)  
- ORM(Object Relational Mapping) : 객체-관계형 데이터베이스를 맵핑
- ORM 프레임워크는 객체와 테이블을 맵핑해서 패러다임의 불일치 문제를 개발자 대신 해결
- 따라서 객체측면에서는 정교한 객체모델링을 할수 있고, 관계형데이터베이스는 데이터베이스에 맞도록 모델링하면 됨 : 맵핑방법만 ORM 프레임워크에 알려주면 됨
- Hibernate : ORM 프레임워크 중 하나, 거의 대부분의 패러다임의 불일치 문제를 해결해주는 성숙한 ORM 프레임워크
- <b style="color:red;">JPA를 사용해야하는 이유?</b>
    - 생산성 : DB설계중심의 패러다임을 객체설계중심으로 역전
    - 유지보수
    - 패러다임의 불일치 해결
    - 성능
    - DB 접근 추상화와 벤더 독립성(DB종류에 따른 사용법이 다름에 대한 독립성)
    - 표준